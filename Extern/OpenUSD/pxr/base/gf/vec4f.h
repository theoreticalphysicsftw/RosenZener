// Modified from the original OpenUSD file.
// Copyright 2024 Mihail Mladenov

//
// Copyright 2016 Pixar
//
// Licensed under the terms set forth in the LICENSE.txt file available at
// https://openusd.org/license.
//
////////////////////////////////////////////////////////////////////////
// This file is generated by a script.  Do not edit directly.  Edit the
// vec.template.h file to make changes.

#ifndef PXR_BASE_GF_VEC4F_H
#define PXR_BASE_GF_VEC4F_H

/// \file gf/vec4f.h
/// \ingroup group_gf_LinearAlgebra

#include "pxr/pxr.h"
#include "pxr/base/tf/diagnostic.h"
#include "pxr/base/gf/api.h"
#include "pxr/base/gf/limits.h"
#include "pxr/base/gf/traits.h"
#include "pxr/base/gf/math.h"
#include "pxr/base/tf/hash.h"

#include <cstddef>
#include <cmath>

#include <iosfwd>

PXR_NAMESPACE_OPEN_SCOPE

class Vec4f;

template <>
struct IsVec<class Vec4f> { static const bool value = true; };

/// \class Vec4f
/// \ingroup group_gf_LinearAlgebra
///
/// Basic type for a vector of 4 float components.
///
/// Represents a vector of 4 components of type \c float.
/// It is intended to be fast and simple.
///
class Vec4f
{
public:
    /// Scalar element type and dimension.
    typedef float ScalarType;
    static const size_t dimension = 4;

    /// Default constructor does no initialization.
    Vec4f() = default;

    /// Initialize all elements to a single value.
    constexpr explicit Vec4f(float value)
        : _data{ value, value, value, value }
    {
    }

    /// Initialize all elements with explicit arguments.
    constexpr Vec4f(float s0, float s1, float s2, float s3)
        : _data{ s0, s1, s2, s3 }
    {
    }

    /// Construct with pointer to values.
    template <class Scl>
    constexpr explicit Vec4f(Scl const *p)
        : _data{ p[0], p[1], p[2], p[3] }
    {
    }

    /// Construct from Vec4d.
    explicit Vec4f(class Vec4d const &other);

    /// Implicitly convert from Vec4h.
    Vec4f(class Vec4h const &other);

    /// Implicitly convert from Vec4i.
    Vec4f(class Vec4i const &other);
 
    /// Create a unit vector along the X-axis.
    static Vec4f XAxis() {
        Vec4f result(0);
        result[0] = 1;
        return result;
    }
    /// Create a unit vector along the Y-axis.
    static Vec4f YAxis() {
        Vec4f result(0);
        result[1] = 1;
        return result;
    }
    /// Create a unit vector along the Z-axis.
    static Vec4f ZAxis() {
        Vec4f result(0);
        result[2] = 1;
        return result;
    }
    /// Create a unit vector along the W-axis.
    static Vec4f WAxis() {
        Vec4f result(0);
        result[3] = 1;
        return result;
    }

    /// Create a unit vector along the i-th axis, zero-based.  Return the zero
    /// vector if \p i is greater than or equal to 4.
    static Vec4f Axis(size_t i) {
        Vec4f result(0);
        if (i < 4)
            result[i] = 1;
        return result;
    }

    /// Set all elements with passed arguments.
    Vec4f &Set(float s0, float s1, float s2, float s3) {
        _data[0] = s0;
        _data[1] = s1;
        _data[2] = s2;
        _data[3] = s3;
        return *this;
    }

    /// Set all elements with a pointer to data.
    Vec4f &Set(float const *a) {
        return Set(a[0], a[1], a[2], a[3]);
    }

    /// Direct data access.
    float const *data() const { return _data; }
    float *data() { return _data; }
    float const *GetArray() const { return data(); }

    /// Indexing.
    float const &operator[](size_t i) const { return _data[i]; }
    float &operator[](size_t i) { return _data[i]; }

    /// Hash.
    friend inline size_t hash_value(Vec4f const &vec) {
        return TfHash::Combine(vec[0], vec[1], vec[2], vec[3]);
    }

    /// Equality comparison.
    bool operator==(Vec4f const &other) const {
        return _data[0] == other[0] &&
               _data[1] == other[1] &&
               _data[2] == other[2] &&
               _data[3] == other[3];
    }
    bool operator!=(Vec4f const &other) const {
        return !(*this == other);
    }

    // TODO Add inequality for other vec types...
    /// Equality comparison.
    GF_API
    bool operator==(class Vec4d const &other) const;
    /// Equality comparison.
    GF_API
    bool operator==(class Vec4h const &other) const;
    /// Equality comparison.
    GF_API
    bool operator==(class Vec4i const &other) const;
    
    /// Create a vec with negated elements.
    Vec4f operator-() const {
        return Vec4f(-_data[0], -_data[1], -_data[2], -_data[3]);
    }

    /// Addition.
    Vec4f &operator+=(Vec4f const &other) {
        _data[0] += other[0];
        _data[1] += other[1];
        _data[2] += other[2];
        _data[3] += other[3];
        return *this;
    }
    friend Vec4f operator+(Vec4f const &l, Vec4f const &r) {
        return Vec4f(l) += r;
    }

    /// Subtraction.
    Vec4f &operator-=(Vec4f const &other) {
        _data[0] -= other[0];
        _data[1] -= other[1];
        _data[2] -= other[2];
        _data[3] -= other[3];
        return *this;
    }
    friend Vec4f operator-(Vec4f const &l, Vec4f const &r) {
        return Vec4f(l) -= r;
    }

    /// Multiplication by scalar.
    Vec4f &operator*=(double s) {
        _data[0] *= s;
        _data[1] *= s;
        _data[2] *= s;
        _data[3] *= s;
        return *this;
    }
    Vec4f operator*(double s) const {
        return Vec4f(*this) *= s;
    }
    friend Vec4f operator*(double s, Vec4f const &v) {
        return v * s;
    }

        /// Division by scalar.
    // TODO should divide by the scalar type.
    Vec4f &operator/=(double s) {
        // TODO This should not multiply by 1/s, it should do the division.
        // Doing the division is more numerically stable when s is close to
        // zero.
        return *this *= (1.0 / s);
    }
    Vec4f operator/(double s) const {
        return *this * (1.0 / s);
    }
    
    /// See Dot().
    float operator*(Vec4f const &v) const {
        return _data[0] * v[0] + _data[1] * v[1] + _data[2] * v[2] + _data[3] * v[3];
    }

    /// Returns the projection of \p this onto \p v. That is:
    /// \code
    /// v * (*this * v)
    /// \endcode
    Vec4f GetProjection(Vec4f const &v) const {
        return v * (*this * v);
    }

    /// Returns the orthogonal complement of \p this->GetProjection(b).
    /// That is:
    /// \code
    ///  *this - this->GetProjection(b)
    /// \endcode
    Vec4f GetComplement(Vec4f const &b) const {
        return *this - this->GetProjection(b);
    }

    /// Squared length.
    float GetLengthSq() const {
        return *this * *this;
    }

    /// Length
    float GetLength() const {
        return Sqrt(GetLengthSq());
    }

    /// Normalizes the vector in place to unit length, returning the
    /// length before normalization. If the length of the vector is
    /// smaller than \p eps, then the vector is set to vector/\c eps.
    /// The original length of the vector is returned. See also Normalize().
    ///
    /// \todo This was fixed for bug 67777. This is a gcc64 optimizer bug.
    /// By tickling the code, it no longer tries to write into
    /// an illegal memory address (in the code section of memory).
    float Normalize(float eps = GF_MIN_VECTOR_LENGTH) {
        // TODO this seems suspect...  suggest dividing by length so long as
        // length is not zero.
        float length = GetLength();
        *this /= (length > eps) ? length : eps;
        return length;
    }

    Vec4f GetNormalized(float eps = GF_MIN_VECTOR_LENGTH) const {
        Vec4f normalized(*this);
        normalized.Normalize(eps);
        return normalized;
    }

  
private:
    float _data[4];
};

/// Output a Vec4f.
/// \ingroup group_gf_DebuggingOutput
GF_API std::ostream& operator<<(std::ostream &, Vec4f const &);


PXR_NAMESPACE_CLOSE_SCOPE

#include "pxr/base/gf/vec4d.h"
#include "pxr/base/gf/vec4h.h"
#include "pxr/base/gf/vec4i.h"

PXR_NAMESPACE_OPEN_SCOPE

inline
Vec4f::Vec4f(class Vec4d const &other)
{
    _data[0] = other[0];
    _data[1] = other[1];
    _data[2] = other[2];
    _data[3] = other[3];
}
inline
Vec4f::Vec4f(class Vec4h const &other)
{
    _data[0] = other[0];
    _data[1] = other[1];
    _data[2] = other[2];
    _data[3] = other[3];
}
inline
Vec4f::Vec4f(class Vec4i const &other)
{
    _data[0] = other[0];
    _data[1] = other[1];
    _data[2] = other[2];
    _data[3] = other[3];
}

/// Returns component-wise multiplication of vectors \p v1 and \p v2.
inline Vec4f
CompMult(Vec4f const &v1, Vec4f const &v2) {
    return Vec4f(
        v1[0] * v2[0],
        v1[1] * v2[1],
        v1[2] * v2[2],
        v1[3] * v2[3]
        );
}

/// Returns component-wise quotient of vectors \p v1 and \p v2.
inline Vec4f
CompDiv(Vec4f const &v1, Vec4f const &v2) {
    return Vec4f(
        v1[0] / v2[0],
        v1[1] / v2[1],
        v1[2] / v2[2],
        v1[3] / v2[3]
        );
}

/// Returns the dot (inner) product of two vectors.
inline float
Dot(Vec4f const &v1, Vec4f const &v2) {
    return v1 * v2;
}


/// Returns the geometric length of \c v.
inline float
GetLength(Vec4f const &v)
{
    return v.GetLength();
}

/// Normalizes \c *v in place to unit length, returning the length before
/// normalization. If the length of \c *v is smaller than \p eps then \c *v is
/// set to \c *v/eps.  The original length of \c *v is returned.
inline float
Normalize(Vec4f *v, float eps = GF_MIN_VECTOR_LENGTH)
{
    return v->Normalize(eps);
}

/// Returns a normalized (unit-length) vector with the same direction as \p v.
/// If the length of this vector is smaller than \p eps, the vector divided by
/// \p eps is returned.
inline Vec4f
GetNormalized(Vec4f const &v, float eps = GF_MIN_VECTOR_LENGTH)
{
    return v.GetNormalized(eps);
}

/// Returns the projection of \p a onto \p b. That is:
/// \code
/// b * (a * b)
/// \endcode
inline Vec4f
GetProjection(Vec4f const &a, Vec4f const &b)
{
    return a.GetProjection(b);
}

/// Returns the orthogonal complement of \p a.GetProjection(b). That is:
/// \code
///  a - a.GetProjection(b)
/// \endcode
inline Vec4f
GetComplement(Vec4f const &a, Vec4f const &b)
{
    return a.GetComplement(b);
}

/// Tests for equality within a given tolerance, returning \c true if the
/// length of the difference vector is less than or equal to \p tolerance.
inline bool
IsClose(Vec4f const &v1, Vec4f const &v2, double tolerance)
{
    Vec4f delta = v1 - v2;
    return delta.GetLengthSq() <= tolerance * tolerance;
}

 
 
PXR_NAMESPACE_CLOSE_SCOPE

#endif // PXR_BASE_GF_VEC4F_H
